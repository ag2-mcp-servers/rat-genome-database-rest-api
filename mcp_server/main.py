# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T04:57:44+00:00



import argparse
import json
import os
from typing import *

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path

from models import (
    QTL,
    AgrAffectedGenomicModelsTaxonIdGetResponse,
    AgrAllelesTaxonIdGetResponse,
    AgrExpressionTaxonIdGetResponse,
    AgrPhenotypesTaxonIdGetResponse,
    AgrTaxonIdGetResponse,
    AgrVariantsTaxonIdGetResponse,
    AnnotatedGeneRequest,
    AnnotationRequest,
    AnnotationsAccIdRgdIdGetResponse,
    AnnotationsAccIdRgdIdGetResponse1,
    AnnotationsAccIdSpeciesTypeKeyIncludeChildrenGetResponse,
    AnnotationsPostResponse,
    AnnotationsReferenceRefRgdIdGetResponse,
    AnnotationsRgdIdRgdIdGetResponse,
    AnnotationsRgdIdRgdIdOntologyPrefixGetResponse,
    Chromosome,
    EnrichmentAnnotatedGenesPostResponse,
    EnrichmentDataPostResponse,
    EnrichmentGeneRequest,
    EnrichmentRequest,
    Gene,
    GenesAffyIdAffyIdSpeciesTypeKeyGetResponse,
    GenesAliasAliasSymbolSpeciesTypeKeyGetResponse,
    GenesAlleleRgdIdGetResponse,
    GenesAnnotationAccIdGetResponse,
    GenesAnnotationAccIdSpeciesTypeKeyGetResponse,
    GenesAnnotationPostResponse,
    GenesChrStartStopMapKeyGetResponse,
    GenesKeywordKeywordSpeciesTypeKeyGetResponse,
    GenesMapMapKeyGetResponse,
    GenesMappedChrStartStopMapKeyGetResponse,
    GenesOrthologsPostResponse,
    GenesOrthologsRgdIdGetResponse,
    GenesRegionChrStartStopMapKeyGetResponse,
    GenesSpeciesSpeciesTypeKeyGetResponse,
    LookupGeneTypesGetResponse,
    LookupIdMapEnsemblGenePostResponse,
    LookupIdMapEnsemblGeneRgdIdGetResponse,
    LookupIdMapEnsemblProteinPostResponse,
    LookupIdMapEnsemblProteinRgdIdGetResponse,
    LookupIdMapEnsemblTranscriptPostResponse,
    LookupIdMapEnsemblTranscriptRgdIdGetResponse,
    LookupIdMapGenBankNucleotidePostResponse,
    LookupIdMapGenBankNucleotideRgdIdGetResponse,
    LookupIdMapGenBankProteinPostResponse,
    LookupIdMapGenBankProteinRgdIdGetResponse,
    LookupIdMapGTExPostResponse,
    LookupIdMapGTExRgdIdGetResponse,
    LookupIdMapHGNCPostResponse,
    LookupIdMapHGNCRgdIdGetResponse,
    LookupIdMapMGIPostResponse,
    LookupIdMapMGIRgdIdGetResponse,
    LookupIdMapNCBIGenePostResponse,
    LookupIdMapNCBIGeneRgdIdGetResponse,
    LookupIdMapUniProtPostResponse,
    LookupIdMapUniProtRgdIdGetResponse,
    LookupMapsSpeciesTypeKeyGetResponse,
    LookupSpeciesTypeKeysGetResponse,
    MapsChrMapKeyGetResponse,
    MapsSpeciesTypeKeyGetResponse,
    OntologyOntAccIdGetResponse,
    OrthologRequest,
    PathwaysDiagramsForCategoryCategoryGetResponse,
    PathwaysDiagramsSearchSearchStringGetResponse,
    PhenotypePhenominerChartSpeciesTypeKeyRefRgdIdTermStringGetResponse,
    PhenotypePhenominerChartSpeciesTypeKeyTermStringGetResponse,
    QtlsChrStartStopMapKeyGetResponse,
    QtlsMappedChrStartStopMapKeyGetResponse,
    RGDIDListRequest,
    SslpsMappedChrStartStopMapKeyGetResponse,
    StatsCountActiveObjectSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountGeneTypeSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountObjectStatusSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountObjectWithReferenceSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountObjectWithRefSeqSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountObjectWithXdbSpeciesTypeKeyObjectKeyDateYYYYMMDDGetResponse,
    StatsCountProteinInteractionSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountQtlInheritanceTypeSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountRetiredObjectSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountStrainTypeSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountWithdrawnObjectSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsCountXdbSpeciesTypeKeyDateYYYYMMDDGetResponse,
    StatsDiffActiveObjectSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffGeneTypeSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffObjectStatusSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffObjectWithReferenceSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffObjectWithRefSeqSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffObjectWithXdbSpeciesTypeKeyObjectKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffProteinInteractionSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffQtlInheritanceTypeSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffRetiredObjectSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffStrainTypeSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffWithdrawnObjectSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsDiffXdbSpeciesTypeKeyDateFromYYYYMMDDDateToYYYYMMDDGetResponse,
    StatsTermAccIdFilterAccIdGetResponse,
    Strain,
    StrainsAllGetResponse,
    StrainsChrStartStopMapKeyGetResponse,
    Term,
)

app = MCPProxy(
    contact={
        'email': 'RGD.Data2@mcw.edu',
        'name': 'Rat Genome Database',
        'url': 'http://rgd.mcw.edu',
        'x-twitter': 'medicalcollege',
    },
    description='The RGD REST API provides programmatic access to information and annotation stored in the Rat Genome Database',
    license={
        'name': 'Creative Commons',
        'url': 'https://creativecommons.org/licenses/by/4.0/legalcode',
    },
    termsOfService='http://rgd.mcw.edu/wg/citing-rgd',
    title='Rat Genome Database REST API',
    version='1.1',
    servers=[{'url': '//rest.rgd.mcw.edu/rgdws'}],
)


@app.get(
    '/agr/affectedGenomicModels/{taxonId}',
    tags=['genomic_model_queries', 'gene_allele_management'],
)
def get_affected_genomic_models_using_g_e_t(taxon_id: str = Path(..., alias='taxonId')):
    """
    Get affected genomic models (rat strains with gene alleles) submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/agr/alleles/{taxonId}',
    tags=['gene_allele_management', 'gene_information_retrieval'],
)
def get_alleles_for_taxon_using_g_e_t(taxon_id: str = Path(..., alias='taxonId')):
    """
    Get gene allele records submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/agr/expression/{taxonId}',
    tags=['expression_and_phenotype_data', 'annotation_data_retrieval'],
)
def get_expression_for_taxon_using_g_e_t(taxon_id: str = Path(..., alias='taxonId')):
    """
    Get expression annotations submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/agr/phenotypes/{taxonId}',
    tags=['expression_and_phenotype_data', 'annotation_data_retrieval'],
)
def get_phenotypes_for_taxon_using_g_e_t(taxon_id: str = Path(..., alias='taxonId')):
    """
    Get phenotype annotations submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/agr/variants/{taxonId}',
    tags=['variant_and_gene_info', 'annotation_data_retrieval'],
)
def get_variants_for_taxon_using_g_e_t(taxon_id: str = Path(..., alias='taxonId')):
    """
    Get basic variant records submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/agr/{taxonId}', tags=['genomic_model_queries', 'gene_information_retrieval'])
def get_genes_for_latest_assembly_using_g_e_t(
    taxon_id: str = Path(..., alias='taxonId')
):
    """
    Get gene records submitted by RGD to AGR by taxonId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/annotations/',
    tags=[
        'annotation_data_retrieval',
        'ontology_term_management',
        'gene_enrichment_retrieval',
    ],
)
def get_annotations_using_p_o_s_t(body: AnnotationRequest = None):
    """
    Return a list of genes annotated to an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/accId/{rgdId}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_term_acc_ids_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Returns a list ontology term accession IDs annotated to an rgd object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/count/{accId}/{includeChildren}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_annotation_count_by_acc_id_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    include_children: bool = Path(..., alias='includeChildren'),
):
    """
    Returns annotation count for ontology accession ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/count/{accId}/{speciesTypeKey}/{includeChildren}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_annotation_count_by_acc_id_and_species_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    include_children: bool = Path(..., alias='includeChildren'),
):
    """
    Returns annotation count for ontology accession ID and speicies
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/count/{accId}/{speciesTypeKey}/{includeChildren}/{objectType}',
    tags=[
        'annotation_data_retrieval',
        'ontology_term_management',
        'ontology_term_statistics',
    ],
)
def get_annotation_count_by_acc_id_and_object_type_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    include_children: bool = Path(..., alias='includeChildren'),
    object_type: int = Path(..., alias='objectType'),
):
    """
    Returns annotation count for ontology accession ID and object type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/reference/{refRgdId}',
    tags=['annotation_data_retrieval', 'gene_information_retrieval'],
)
def get_annots_by_refrerence_using_g_e_t(ref_rgd_id: int = Path(..., alias='refRgdId')):
    """
    Returns a list of annotations for a reference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/rgdId/{rgdId}',
    tags=['annotation_data_retrieval', 'gene_information_retrieval'],
)
def get_annotations_by_rgd_id_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Returns a list of annotations by RGD ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/rgdId/{rgdId}/{ontologyPrefix}',
    tags=['annotation_data_retrieval', 'gene_information_retrieval'],
)
def get_annotations_by_rgd_id_and_ontology_using_g_e_t(
    rgd_id: int = Path(..., alias='rgdId'),
    ontology_prefix: str = Path(..., alias='ontologyPrefix'),
):
    """
    Returns a list of annotations by RGD ID and ontology prefix
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/{accId}/{rgdId}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_annotations_by_acc_id_and_rgd_id_using_g_e_t(
    acc_id: str = Path(..., alias='accId'), rgd_id: int = Path(..., alias='rgdId')
):
    """
    Returns a list of annotations by RGD ID and ontology term accession ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/annotations/{accId}/{speciesTypeKey}/{includeChildren}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_annotations_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    include_children: bool = Path(..., alias='includeChildren'),
):
    """
    Returns a list annotations for an ontology term or a term and it's children
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/enrichment/annotatedGenes',
    tags=[
        'annotation_data_retrieval',
        'gene_enrichment_retrieval',
        'gene_information_retrieval',
    ],
)
def get_enrichment_data_using_p_o_s_t(body: EnrichmentGeneRequest):
    """
    Return a list of genes annotated to the term.Genes are rgdids separated by comma.Species type is an integer value.term is the ontology
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/enrichment/data',
    tags=[
        'annotation_data_retrieval',
        'gene_enrichment_retrieval',
        'ontology_term_management',
    ],
)
def get_enrichment_data_using_p_o_s_t_1(body: EnrichmentRequest):
    """
    Return a chart of ontology terms annotated to the genes.Genes are rgdids separated by comma.Species type is an integer value.Aspect is the Ontology group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/affyId/{affyId}/{speciesTypeKey}',
    tags=['gene_lookup_by_identifiers', 'gene_information_retrieval'],
)
def get_genes_by_affy_id_using_g_e_t(
    affy_id: str = Path(..., alias='affyId'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
):
    """
    Return a list of genes for an affymetrix ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/alias/{aliasSymbol}/{speciesTypeKey}',
    tags=['gene_lookup_by_identifiers', 'gene_information_retrieval'],
)
def get_genes_by_alias_symbol_using_g_e_t(
    alias_symbol: str = Path(..., alias='aliasSymbol'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
):
    """
    Return a list of genes for an alias and species
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/allele/{rgdId}',
    tags=['gene_allele_management', 'gene_information_retrieval'],
)
def get_gene_alleles_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Return a list of gene alleles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/genes/annotation',
    tags=[
        'annotation_data_retrieval',
        'gene_enrichment_retrieval',
        'ontology_term_management',
    ],
)
def get_annotated_genes_using_p_o_s_t(body: AnnotatedGeneRequest = None):
    """
    Return a list of genes annotated to an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/annotation/{accId}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_all_annotated_genes_using_g_e_t(acc_id: str = Path(..., alias='accId')):
    """
    Return a list of genes annotated to an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/annotation/{accId}/{speciesTypeKey}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_genes_annotated_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    species_type_key: int = Path(..., alias='speciesTypeKey'),
):
    """
    Return a list of genes annotated to an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/keyword/{keyword}/{speciesTypeKey}',
    tags=['gene_lookup_by_identifiers', 'gene_information_retrieval'],
)
def get_genes_by_keyword_using_g_e_t(
    keyword: str, species_type_key: int = Path(..., alias='speciesTypeKey')
):
    """
    Return a list of genes by keyword and species type key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/map/{mapKey}',
    tags=[
        'gene_location_queries',
        'mapping_information_operations',
        'gene_information_retrieval',
    ],
)
def get_gene_by_map_key_using_g_e_t(map_key: int = Path(..., alias='mapKey')):
    """
    Return a list of all genes with position information for an assembly
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/mapped/{chr}/{start}/{stop}/{mapKey}',
    tags=['gene_location_queries', 'variant_and_gene_info'],
)
def get_mapped_genes_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Return a list of genes position and map key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/genes/orthologs', tags=['ortholog_data_retrieval'])
def get_orthologs_by_list_using_p_o_s_t(body: OrthologRequest):
    """
    Return a list of gene orthologs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/orthologs/{rgdId}',
    tags=[
        'ortholog_data_retrieval',
        'gene_information_retrieval',
        'gene_lookup_by_identifiers',
    ],
)
def get_gene_orthologs_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Return a list of gene orthologs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/region/{chr}/{start}/{stop}/{mapKey}',
    tags=['gene_location_queries', 'gene_information_retrieval'],
)
def get_genes_in_region_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Return a list of genes in region
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/species/{speciesTypeKey}',
    tags=['gene_information_retrieval', 'gene_lookup_by_identifiers'],
)
def get_genes_by_species_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey')
):
    """
    Return a list of all genes for a species in RGD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/{chr}/{start}/{stop}/{mapKey}',
    tags=[
        'gene_location_queries',
        'variant_and_gene_info',
        'gene_information_retrieval',
    ],
)
def get_genes_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Return a list of genes position and map key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/{rgdId}',
    tags=[
        'gene_information_retrieval',
        'annotation_data_retrieval',
        'gene_lookup_by_identifiers',
    ],
)
def get_gene_by_rgd_id_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Get a gene record by RGD ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genes/{symbol}/{speciesTypeKey}',
    tags=['gene_information_retrieval', 'gene_lookup_by_identifiers'],
)
def get_gene_by_symbol_using_g_e_t(
    symbol: str, species_type_key: int = Path(..., alias='speciesTypeKey')
):
    """
    Get a gene record by symbol and species type key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/geneTypes', tags=['available_gene_types', 'gene_information_retrieval']
)
def get_gene_types_using_g_e_t():
    """
    Returns a list of gene types avialable in RGD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/EnsemblGene',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_ensembl_gene_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to Ensembl Gene IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/EnsemblGene/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_ensembl_gene_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an Ensembl Gene  ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/EnsemblProtein',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_ensembl_protein_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to Ensembl Protein IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/EnsemblProtein/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_ensembl_protein_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an Ensembl Protein ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/EnsemblTranscript',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_ensembl_transcript_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to Ensembl Transcript IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/EnsemblTranscript/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_ensembl_transcript_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an Ensembl Transcript ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/GTEx',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_g_t_e_x_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to GTEx IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/GTEx/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_g_t_e_x_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an GTEx ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/GenBankNucleotide',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_gen_bank_nucleotide_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to GenBank Nucleotide IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/GenBankNucleotide/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_gen_bank_nucleotide_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to a GenBank Nucleotide ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/GenBankProtein',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_gen_bank_protein_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to GenBank Protein IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/GenBankProtein/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_gen_bank_protein_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to a GenBank Protein ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/HGNC',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_h_g_n_c_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to HGNC IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/HGNC/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_h_g_n_c_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an HGNC ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/MGI',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_m_g_i_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to MGI IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/MGI/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_m_g_i_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an MGI ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/NCBIGene',
    tags=['gene_identifier_mapping', 'gene_information_retrieval'],
)
def get_n_c_b_i_gene_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to NCBI Gene IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/NCBIGene/{rgdId}',
    tags=['gene_identifier_mapping', 'gene_information_retrieval'],
)
def get_n_c_b_i_gene_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to an NCBI Gene ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lookup/id/map/UniProt',
    tags=[
        'gene_identifier_mapping',
        'gene_information_retrieval',
        'annotation_data_retrieval',
    ],
)
def get_uni_prot_mapping_using_p_o_s_t(body: RGDIDListRequest = None):
    """
    Translate RGD IDs to UniProt IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/id/map/UniProt/{rgdId}',
    tags=[
        'gene_identifier_mapping',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_uni_prot_mapping_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Translate an RGD ID to a UniProt ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/maps/{speciesTypeKey}',
    tags=['mapping_information_operations', 'genomic_model_queries'],
)
def get_maps_using_g_e_t(species_type_key: int = Path(..., alias='speciesTypeKey')):
    """
    Return a list assembly maps for a species
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/speciesTypeKeys',
    tags=[
        'mapping_information_operations',
        'available_gene_types',
        'annotation_data_retrieval',
    ],
)
def get_species_types_using_g_e_t():
    """
    Return a Map of species type keys available in RGD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lookup/standardUnit/{accId}',
    tags=['ontology_term_management', 'annotation_data_retrieval'],
)
def get_maps_using_g_e_t_1(acc_id: str = Path(..., alias='accId')):
    """
    Return a standardUnit for an ontology if it exists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/maps/chr/{chromosome}/{mapKey}', tags=['chromosome_information_retrieval'])
def get_chromosome_by_assembly_using_g_e_t(
    chromosome: str, map_key: int = Path(..., alias='mapKey')
):
    """
    Return a list of chromosomes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/maps/chr/{mapKey}',
    tags=['chromosome_information_retrieval', 'gene_location_queries'],
)
def get_chromosomes_by_assembly_using_g_e_t(map_key: int = Path(..., alias='mapKey')):
    """
    Return a list of chromosomes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/maps/{speciesTypeKey}',
    tags=['mapping_information_operations', 'genomic_model_queries'],
)
def get_maps_by_species_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey')
):
    """
    Return a list of assemblies
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/ont/{accId}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_ont_dags_using_g_e_t(acc_id: str = Path(..., alias='accId')):
    """
    Returns child and parent terms for Accession ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/term/{accId1}/{accId2}',
    tags=['gene_identifier_mapping', 'annotation_data_retrieval'],
)
def is_descendant_of_using_g_e_t(
    acc_id1: str = Path(..., alias='accId1'), acc_id2: str = Path(..., alias='accId2')
):
    """
    Returns true or false for terms
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/term/{accId}',
    tags=['annotation_data_retrieval', 'ontology_term_management'],
)
def get_term_using_g_e_t(acc_id: str = Path(..., alias='accId')):
    """
    Returns term for Accession ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pathways/diagrams/search/{searchString}', tags=['pathway_information_retrieval']
)
def search_pathways_using_g_e_t(search_string: str = Path(..., alias='searchString')):
    """
    Return a list of pathways based on search term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pathways/diagramsForCategory/{category}', tags=['pathway_information_retrieval']
)
def get_pathways_with_diagrams_for_category_using_g_e_t(category: str):
    """
    Return a list of pathways based on category provided
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phenotype/phenominer/chart/{speciesTypeKey}/{refRgdId}/{termString}',
    tags=[
        'expression_and_phenotype_data',
        'annotation_data_retrieval',
        'strain_data_analysis',
    ],
)
def get_chart_info_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    ref_rgd_id: int = Path(..., alias='refRgdId'),
    term_string: str = Path(..., alias='termString'),
):
    """
    Return a list of quantitative phenotypes values based on a combination of Clinical Measurement, Experimental Condition, Rat Strain, and/or Measurement Method ontology terms.  Results will be all records that match all terms submitted.  Ontology ids should be submitted as a comma delimited list (ex. RS:0000029,CMO:0000155,CMO:0000139).  Species type is an integer value (3=rat, 4=chinchilla).  Reference RGD ID for a study works like a filter.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phenotype/phenominer/chart/{speciesTypeKey}/{termString}',
    tags=[
        'expression_and_phenotype_data',
        'ontology_term_management',
        'strain_data_analysis',
    ],
)
def get_chart_info_using_g_e_t_1(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    term_string: str = Path(..., alias='termString'),
):
    """
    Return a list of quantitative phenotypes values based on a combination of Clinical Measurement, Experimental Condition, Rat Strain, and/or Measurement Method ontology terms.  Results will be all records that match all terms submitted.  Ontology ids should be submitted as a comma delimited list (ex. RS:0000029,CMO:0000155,CMO:0000139).  Species type is an integer value (3=rat, 4=chinchilla)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/qtls/mapped/{chr}/{start}/{stop}/{mapKey}',
    tags=[
        'quantitative_trait_locus_data',
        'gene_location_queries',
        'mapping_information_operations',
    ],
)
def get_mapped_q_t_l_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Returns a list QTL for given position and assembly map
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/qtls/{chr}/{start}/{stop}/{mapKey}',
    tags=[
        'quantitative_trait_locus_data',
        'mapping_information_operations',
        'gene_location_queries',
    ],
)
def get_qtl_list_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Returns a list QTL for given position and assembly map
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/qtls/{rgdId}',
    tags=[
        'quantitative_trait_locus_data',
        'annotation_data_retrieval',
        'gene_information_retrieval',
    ],
)
def get_q_t_l_by_rgd_id_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Return a QTL for provided RGD ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sslps/mapped/{chr}/{start}/{stop}/{mapKey}',
    tags=['gene_location_queries', 'mapping_information_operations'],
)
def get_mapped_s_s_l_p_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Returns a list SSLP for given position and assembly map
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/activeObject/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting'],
)
def get_active_object_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of active objects by type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/geneType/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'available_gene_types',
        'gene_information_retrieval',
    ],
)
def get_gene_type_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of gene types, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/objectStatus/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting'],
)
def get_object_status_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of objects with given status, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/objectWithRefSeq/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting'],
)
def get_objects_with_ref_seq_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of objects with reference sequence(s), by object type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/objectWithReference/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting'],
)
def get_objects_with_reference_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of objects with reference, by object type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/objectWithXdb/{speciesTypeKey}/{objectKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'object_retirement_statistics'],
)
def get_objects_with_x_d_bs_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    object_key: int = Path(..., alias='objectKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of objects with external database ids, by database id, for specified species, object type and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/proteinInteraction/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'protein_interaction_differentials'],
)
def get_protein_interaction_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of protein interactions, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/qtlInheritanceType/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=[
        'quantitative_trait_locus_data',
        'biological_object_counting',
        'qtl_strain_inheritance_analysis',
    ],
)
def get_qtl_inheritance_type_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of strains, by qtl inheritance type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/retiredObject/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'object_retirement_statistics'],
)
def get_retired_object_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of retired objects by type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/strainType/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'strain_data_analysis'],
)
def get_strain_type_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of strain types, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/withdrawnObject/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'object_retirement_statistics'],
)
def get_withdrawn_object_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of withdrawn objects by type, for specified species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/count/xdb/{speciesTypeKey}/{dateYYYYMMDD}',
    tags=['biological_object_counting', 'object_retirement_statistics'],
)
def get_xdbs_count_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_y_y_y_y_m_m_d_d: str = Path(..., alias='dateYYYYMMDD'),
):
    """
    Count of external database ids, for specied species and date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/activeObject/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=['biological_object_counting', 'differential_object_count_analysis'],
)
def get_active_object_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of active objects, by type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/geneType/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=['biological_object_counting', 'differential_object_count_analysis'],
)
def get_gene_type_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of gene types, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/objectStatus/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=['biological_object_counting', 'differential_object_count_analysis'],
)
def get_object_status_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of objects with given status, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/objectWithRefSeq/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=['biological_object_counting', 'differential_object_count_analysis'],
)
def get_objects_with_ref_seq_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of objects with reference sequence(s), by object type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/objectWithReference/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=['biological_object_counting', 'differential_object_count_analysis'],
)
def get_objects_with_reference_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of objects with reference, by object type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/objectWithXdb/{speciesTypeKey}/{objectKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'object_retirement_statistics',
    ],
)
def get_objects_with_x_d_bs_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    object_key: int = Path(..., alias='objectKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of objects with external database ids, by database id, for specified species, object type and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/proteinInteraction/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'protein_interaction_differentials',
    ],
)
def get_protein_interaction_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of protein interactions, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/qtlInheritanceType/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'quantitative_trait_locus_data',
        'differential_object_count_analysis',
        'qtl_strain_inheritance_analysis',
    ],
)
def get_qtl_inheritance_type_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of strains, by qtl inheritance type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/retiredObject/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'object_retirement_statistics',
    ],
)
def get_retired_object_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of retired objects, by type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/strainType/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'strain_data_analysis',
    ],
)
def get_strain_type_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of strain types, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/withdrawnObject/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'object_retirement_statistics',
    ],
)
def get_withdrawn_object_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of withdrawn objects, by type, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/diff/xdb/{speciesTypeKey}/{dateFromYYYYMMDD}/{dateToYYYYMMDD}',
    tags=[
        'biological_object_counting',
        'differential_object_count_analysis',
        'object_retirement_statistics',
    ],
)
def get_xdbs_diff_using_g_e_t(
    species_type_key: int = Path(..., alias='speciesTypeKey'),
    date_from_y_y_y_y_m_m_d_d: str = Path(..., alias='dateFromYYYYMMDD'),
    date_to_y_y_y_y_m_m_d_d: str = Path(..., alias='dateToYYYYMMDD'),
):
    """
    Count difference of external database ids, for specified species and date range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/term/{accId}/{filterAccId}',
    tags=['gene_information_retrieval', 'gene_lookup_by_identifiers'],
)
def get_term_stats_using_g_e_t(
    acc_id: str = Path(..., alias='accId'),
    filter_acc_id: str = Path(..., alias='filterAccId'),
):
    """
    getTermStats
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/strains/all', tags=['strain_data_analysis', 'genomic_model_queries'])
def get_all_strains_using_g_e_t():
    """
    Return all active strains in RGD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/strains/{chr}/{start}/{stop}/{mapKey}',
    tags=['strain_data_analysis', 'gene_location_queries'],
)
def get_strains_by_position_using_g_e_t(
    chr: str,
    start: int = ...,
    stop: int = ...,
    map_key: int = Path(..., alias='mapKey'),
):
    """
    Return all active strains by position
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/strains/{rgdId}',
    tags=[
        'annotation_data_retrieval',
        'gene_information_retrieval',
        'gene_identifier_mapping',
    ],
)
def get_strain_by_rgd_id_using_g_e_t(rgd_id: int = Path(..., alias='rgdId')):
    """
    Return a strain by RGD ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
